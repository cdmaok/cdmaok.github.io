---
layout: post
title: Fast Query
category: Web
description: 总结一些看到的查询优化的技巧
---

总结一些看到的查询优化的技巧。  

#### Intro
  就接触到的一些项目而言，目前大多的项目结构是MVC结构的，后台会提供一部分restAPI的接口，前端调用后台提供的API，而不是直接查询数据，后台接收API的请求，然后转发去查询数据库获得的结果。  
  这样做的好处主要是避免了数据库和客户端直接接触，相对安全，后台在转发数据库查询时可以自定义一些操作，比如说过载保护，重新定义字段等，相对灵活。  

### Basic
	从Client发出一次查询请求可能发生了以下事情：
	1. Client发送 Rest API 到后台(HTTP 请求)
	2. 后台接受 API 调用后 重写查询语句，可能需要适配到不同的数据库等
	3. 数据库查询结果
	4. 后台接受查询结果，然后转发给Client

以下展开每个地方可能有的优化。  

####	Step 1
 感觉还好，可优化的地方不多。如果流量加大的话，可以在后台前边布置一个均衡代理（反向机制），如图所示，简单的来说就是代理在http的请求中加上Location一项，浏览器会收到一个状态码为300的请求，浏览器主动向Location中指定的URL再次发送请求。  
![负载均衡][nginx-balance]   

####	Step 2
 这个地方可以进行**缓存**，设置一个队列或者其他数据结构，当接受数据请求时，首先到缓存中去查询结果，如果命中了就直接返回结果，不去查询服务器，当然这样也会引来缓存一致性的问题，比较成熟的方法是使用Redis或者Memcached构造一个缓存服务器加速查询结果。  

#### Step 3
数据库查询过程中可供优化的部分包括  
		a. 增加常用字段的**索引**，加速常用查询的速度  
		b. 数据库**集群**，多机查询。主要应对高并发的环境，可以起到均衡负载的作用，减少了队列中等待的查询语句的等待时间。

#### Step 4
在转发结果到Client的时候可以进行一些Http Header的优化。  
* __Last-Modified__ 和 __If-Modified-Since__，在返回结果的时候，后台可以加上Last-Modified:xxxx-xx-xx这一项，Client(浏览器)会对这一结果进行缓存，当用户再次请求这一资源时,会加上If-Modified-Since，后台会比较If-Modified-Since的时间和请求资源的最后修改时间，如果命中了缓存的话，**后台不会返回一个有实质内容的response，而是一个304的response，告诉浏览器使用自己的缓存**，和这个类似的包括(Etag/If-None-Match)，(Expires/Cache-Control)直接告诉Client资源的有效期，减少了第二次请求。  
* __Keep-Alive__：正常而言每次请求都要重新建立连接，在Http Headerzhong中加上这一项可以避免这一问题，事实上，这个项应该在Step 1 中描述。  
如果Client是浏览器的话，更加希望使用异步加载的方法，避免获得数据之后重新渲染整个页面，带来时间上的损耗。  



[nginx-balance]: http://7xpv97.com1.z0.glb.clouddn.com/web-nginx-balance.png
