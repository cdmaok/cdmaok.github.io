---
layout: post
title:  Learning to rank
description: Learning to rank
categories: Machine Learning
---

Learning To Rank(排序学习)最早用于信息检索领域[15]。排序学习的方法旨在利用机器学习的思想训练一个排序模型。以信息检索为例，当用户提交查询时，排序模型会将检索返回的所有条目进行二次排序返回。在信息检索领域，检索返回的条目通常是根据相关性排序返回的，也称之为相关性排序。也就是说，给定一个查询，如果一个条目和其他条目相比而言与查询相关性更高，那么这个条目的排序会更高。然而，相关性是一个重要但是不够全面的特征。例如，重要程度（政府部门，官方机构的条目）和用户偏好是两个重要的需要考虑的因素。排序模型可以利用这些更多的特征对检索提出来的条目进行更好的排序。总体而言，排序学习可以训练出一个更加灵活复杂的排序模型，不再依赖于单一指标排序或者人工指定规则排序。接下来对排序学习做形式化的定义，
[x_i,y_i] ，其中x_i 为特征向量，y_i 是顺序，可以作为分类问题，也可以作为回归问题求解。总的来说有三种方法，分别是Pointwise,Pairwise,Listwise。

Pointwise是排序学习中最早期的方法，把排序标签当作连续值，把排序学习当作一个标准的回归问题，求解回归模型中的参数即可。常见的算法有RankProp，Prank，OAP-BPM等。
Pairwise 方法和Pointwise 方法比起来有很多好处主要在于标签空间的对待。
Pairwise方法中，所有文档的顺序关系问题被转化为文档之间文档对的先后顺序问题。这一转化相当的耗时。
在Pointwise（回归问题）中，标签空间被当作无序的有限空间，Pairwise中则被视为有限的排序集合。RankNet [16]自定义了一个损失函数，根据文档对之间的先后关系训练了一个神经网络，通过神经网络给出的预测值排序。 RankSVM[17]把文档对的先后顺序视作一个二分类问题拟合出一个最大边缘，通过每个文档到最大边缘的距离决定先后关系。
Listwise的方法不如以上两者多，更像是以上两种方法的折衷方法。在前两种方法中，文档或者文档请求对如果有明确的特征或者属性，那么训练的得到的模型将十分有效显著。但有些场景中，特征并不明确，会根据请求而改变。此外，排序学习的评价方法和训练过程中的损失函数并不一致等等。ListRank[18]中把请求和所有的得到的文档作为一个实例，把文档的排序看做是文档的一个排列，通过启发式的定义一个损失函数确定一个损失最小的排列方法完成排序过程。lamdbaRank是基于ranknet的改进，目标函数不仅仅是交叉熵而是交叉熵和IR指标（NDCG，ERR）的乘积


### RankSVM
![ranksvm](http://7xpv97.com1.z0.glb.clouddn.com/70f1ddecc665ee4309010411d0cab965.png)
![ranksvm-formula](http://7xpv97.com1.z0.glb.clouddn.com/c484f6c996499105251e8329a81aa908.png)
![ranksvm-target](http://7xpv97.com1.z0.glb.clouddn.com/6feb061aae6e15ffeb949985030646fd.png)
对约束进行化简，可以得到一个pairwise的二分类问题。
之前不理解为什么是两个matching vector 相减，通过这个约束的化简也可以明白。
因为原问题是在权重向量上的投影的大小。所以是w和x向量相乘，化简的时候自然可以看成是相减。
在做分类问题的时候，也是计算投影，然后按照投影的大小直接排序。跟之前我想的不一样。雪崩
可以理解成MAP，平均准确率。
用SVM的形式表达
